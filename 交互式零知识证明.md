## 多项式
#### 多项式的特性
###### 多项式的知识
一个多项式的知识，就是该多项式的系数。    
![image](http://latex.codecogs.com/gif.latex?\\{y^{n}})


###### Schwatz-Zippel多项式定理
- 如果我们有两个阶为 d 的不相等多项式，他们相交的点数不会超过 d
- 我们不可能找到两条不同的曲线，他们会在某段区域内重合（他们只会相交于一些点）
- 由于上述两个原因，任何多项式在任意点的计算结果都可以看做是其唯一身份的表示（概率意义上），这构成了以多项式曲线上某随机点证明某个多项式的基础

###### 基于Schwatz-Zippel定理的证明
一个 prover 声称他知道一些 verifier也知道的多项式（无论多项式的阶数有多大）时，他们就可以按照一个简单的协议去验证：
1. verifier 选择一个随机值 x 并在本地计算多项式结果
2. verifier 将 x 值给到 prover，并让他计算相关的多项式结果
3. prover 代入 x 到多项式计算并将结果给到 verifier
4. verifier 检查本地的计算结果和 prover 的计算结果是否相等，如果相等那就说明 prover 的陈述具有较高的可信度

- 问题1：点3成立的理由应该是校验点的随机性，而不是Schwatz-Zippel定理？
- 缺陷1：verifier和prover都知道此多项式
- 缺陷2：verifier选择的随机点x是明文给prover的，存在信息泄露的风险

###### 基于多项式因式分解的证明
- prover知道p(x) 的证明流程
    1. 将p(x)进行因式分解，p(x) = t(x)·h(x)， 其中，tx = (x-a0)(x-a1)…(x-an) , h(x)则是辅助多项式。a0...an是方程p(x) = 0的解。
    2. verifier知道t(x)
    3. verifier 挑选一个随机值 r, 计算 t = t(r) (即，求值) ，然后将 r 发送给 prover
    4. prover 计算 h(x) =p(x) / t(x) ，并对 p(r) 和 h(r) 进行求值，将计算结果 p, h 提供给 verifier
    5. verifier 验证 p= t⋅h，如果多项式相等，就意味着 t(x) 是 p(x) 的因式。
- 上述证明解决了[基于Schwatz-Zippel定理的证明]的缺陷: verifier只需要知道t(x),不需要知道p(x)
- 上述证明有如下明显缺陷：
    1. prover 可能并不知道他所声称的 p(x)，他可以先算一下  t = t(r)，然后选择一个随机值 h，由此计算出 p = t⋅h。因为等式是成立的，所以也能通过 verifier 的校验。
    2. 因为 prover 知道随机点 x = r ，他可以构造出一个任意的多项式，这个任意多项式与 t(r) ⋅ h(r) 在 r 处有共同点。
    3. 在前面的「陈述」中，prover声称他知道一个特定阶数的多项式，但现在的协议对阶数并没有明确的要求。因而 prover 完全可以拿一个满足因式校验的更高阶数的多项式来欺骗 verifier。
- 上述证明的前两点缺陷，是由于verifier明文传送随机值r给prover导致的。


## 同态隐藏
#### 同态加密
选择一个基础的（基数需要具有某些特定的属性）的自然数 g（如 5），然后我们以要加密的值为指数对 g 进行求幂后，进行模运算。

```math
E(v) = g^v\ (mod\ n)
```
这里 v 就是我们要加密的值, n是模。当n和v都足够大的时候，从E(v)值找回v值，是比较难的。

#### 同态乘法

```math
E(v) = (g^n) ^ m\ (mod\ n) = g ^ {x * y }\ (mod\ n)
```


#### 同态加法
```math
E(v) = (g^i) * (g^j)\ (mod\ n) = g^{i+j}\ (mod\ n)
```

#### 多项式的同态加密
```math
g^{x³-3x²+2x} \ (mod\ n)= (g^{x³})^1 · (g^{x²})^{-3} ·(g^x)^2 \ (mod\ n)  = g^{1x³} · (g^{-3x²})·(g^{2x}) \ (mod\ n)
```
通过这些运算，我们就获得了多项式在一些未知数 x处的加密计算结果。因为同态的性质，同一个多项式的加密运算在加密空间中始终是相同的。

#### 基于多项式的同态加密的证明
###### 证明
- Verifier
     1. 取一个随机数 s ，也就是秘密值
     2. 指数 i 取值为 0，1，…，d 时分别计算出 s 的 i 次幂的加密结果，即：代入 s 计算未加密的目标多项式：t(s)
     3. 将对 s 的幂的加密值提供给 prover：
```math
     g^{s^0},g^{s^1},g^{s^2}...g^{s^d}
```     
- Prover  
     1. 计算多项式h(x) = p(x)/t(x)
     2. 根据多项式的同态加密公式，使用verifier传递的加密值
```math
     g^{s^0},g^{s^1},g^{s^2}...g^{s^d}
```     
和系数c_0，c_1，…，c_d 计算 g^p(s)，然后同样计算 g^h(s)，然后将结果 g^p(s) 和 g^h(s) 提供给 verifier

- Verifier
     1. verifier 去校验 p(s) = t(s) * h(s)，可推出： 
```math
g^{p(s)} = (g^{h(s)})^{t(s)} = g^{h(s)*t(s)}
```

###### 缺陷
上述证明中我们是通过对秘密值s的幂的加密值再进行求幂来对系数进行“赋值”。我们已经限制了 prover 对 s 幂的加密值的选择, 但是这个限制并不是强制的，也就是说，prover 可以使用任何可能的方法找到满足下面等式的值
```math
g^{p'} = g^{h'*t(s)}
```
再用这两个值来代替  gᵖ'  和 gʰ'  将它交给 verifier。所以 verifier 需要能够证明 prover 给出的值就是用s幂的加密值而不是其它值计算出来的。  
**问题**：t(s)值此时prover是否知道？若不知道，他怎么找得出gᵖ'  和 gʰ' 呢？

## Knowledge-of-Exponent Assumption (简称 KEA) 
#### 协议
1. Alice 有一个值a，她想要 Bob 对其进行任意指数的求幂（这里 a是一个有限域群的生成器），唯一的要求是只能对 a 进行求幂，为了保证这一点，她要：
选择一个随机数 q,计算 
```math
a' = a^q\ (mod\ n)
```
2. 提供一个元组 (a, a') 给 Bob, 然后让他对这两个值执行任意的求幂运算，返回结果元组 (b, b')，这里的指数 “q-变换” 依然保持不变，即 

```math
b' = b^q\ (mod\ n)
```

3. 因为 Bob 无法从元组 (a, a') 中提取 q 的值，通过暴力破解也难以实现，那就可以推断 Bob 生成有效元组的唯一方法就是执行下面的步骤：
    1. 选择一个值 c
    2. 计算 b=(a)^c (mod n) 和 b' = (a')^c (mod n)
    3. 回复 (b,b')

c) 有了回复的元组和 α，Alice 就可以验证等式：

```math
    (b)^q = b' 
```

这个协议提供了一个证明给 Alice ，Bob 确实是用他知道的某个值对 a进行求幂的，而且他也不能做别的任何操作，例如：乘法，加法，因为这样就会破坏q-变换关系，解决了[基于多项式的同态加密的证明]中的证明的缺陷。

#### 多项式的KEA协议
现在我们可以扩展这种单项式上的方法到多项式上，因为计算是先将每项的分配分开计算然后再 “同态地” 相加在一起的。

所以如果给定prover一个指数为s的幂以及它们的变换的加密值，他就可以计算原始的和变换后的多项式，这里也必须要满足同样的校验。

对于阶数为 d 的多项式：

**verifier:**
1. 选择随机值q
2. 提供加密值
```math
g^{s^0}, g^{s^1}, g^{s^2}...g^{s^d}
```
和他们的变换
```math
g^{q{s^0}}, g^{q{s^1}}, g^{q{s^2}}...g^{q{s^d}}
```

**prover:**
1. 计算给定的带有 s 的幂的加密多项式
```math
 g^{p(s)} = g^{c_0*{s^0}} * g^{c_1*{s^1}} * g^{c_2*{s^2}}... * g^{c_d*{s^d}}
```

2. 计算给定的带有 s 的幂的转换的加密“转换”多项式：
```math
 g^{p'(s)} = g^{c_0*q*{s^0}} * g^{c_1*q*{s^1}} * g^{c_2*q*{s^2}}... * g^{c_d*q*{s^d}} = (g^{c_0*{s^0}} * g^{c_1*{s^1}} * g^{c_2*{s^2}}... * g^{c_d*{s^d}})^q = (g^{p(s)})^q
 
```

3. 将计算结果 g^{p(s)} 和  g^{p'(s)}, 发给verfier

**verifier:**
若
```math
 g^{p'(s)} = g^{q*p(s)}
 
```
则说明：prover很大概率上是使用verifier提供的数据进行同态加密计算的，因为prover并不知道q的值。

## 零知识提取
如[Knowledge-of-Exponent Assumption]节所讲，我们已基本完成交互式的多项式证明。

但还有一个问题：verifier 可能能够从 prover发送的结果数据g^h(s),g^p(s)和g^p'(s)中提取未知多项式p(x)的知识，我们如何选择证明使得这个校验依然有效，同时又保证没有知识能被提取？

#### 协议
prover:
1. 使用随机值 δ (delta)来“变换”这些值

```math
g^{p(s) * δ}
```
```math
g^{p'(s) * δ}
```
```math
g^{h(s) * δ}
```

verifier:
1.  验证
```math
g^{p(s) * δ} = g^{h(s) * δ * t(s)}
```
```math
g^{p'(s) * δ} = g^{p(s) * δ * q}
```
如此，就对prover发过来结果数据进行了随机变形，但verifier虽然不知道该随机数，但仍然能够对结果进行验证。
