<center>PBFT协议随解</center>

## 协议目的
PBFT 算法和 Raft 算法解决的核心问题都是在分布式环境下如何保持集群状态的一致性，简而言之就是一组服务，给定一组操作，最后得到一致的结果。

PBFT 算法假设的环境又比 Raft 算法更加的’恶劣‘，Raft 算法只支持容错故障节点，而 PBFT 算法除了需要支持容错故障节点之外，还需要容忍作恶节点。

作恶节点节点是指可能对接收到的消息作出截然相反的回复，甚至伪造消息。

## 系统模型
#### FLP原理
###### 同步与异步
所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回，但是一旦调用返回，就得到返回值了。

所谓异步，调用在发出之后，这个调用就直接返回了，所以没有返回结果，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。

###### FLP不可能原理
在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法。

#### 模型
###### 节点
- 节点可以Crash失效，也可以是非可信节点，但两者有数量限制
- 所有节点必须是确定性的。也就是说，在给定状态和参数相同的情况下，操作执行的结果必须相同
- 所有节点必须从相同的状态开始执行。

###### 网络
- 异步网络
- 所有网络信道都是可靠的。可靠的涵义是：允许有延迟，乱序，丢包，**但最终一定会在上限时间t内被送达**。这一点从工程实现上绕过了FLP不可能定理，使得在异步网络中也能达成共识。
 
###### 加密算法破解能力
攻击者算力有限，不能破解加密算法（包括hash，公钥算法等）

## 核心图

![image](https://bbtcdn.8btc.com/data/attachment/portal/201609/26/144657nfww55csw5pv5zvw.png)

## 角色
client, primary node，replica node

## 算法

#### 朴素原理
像所有的科学原理一样，其实最核心的那点东西其实很朴素。就PBFT而言，作者的想法大概如下： 
依据每个节点（包括primary节点和每个replica节点）收到除自身节点外其他节点发来的request的数量n，如果n达到某个阈值t，说明该request已经得到了多数节点的同意，那么PBFT共识达成。

#### 消息格式
- pre-prepare - <<PRE-PREPARE,v,n,d>,m>   

  v是视图编号，m是客户端发送的请求消息，d是请求消息m的摘要，n是主节点分配的一个序列号。
  
- prepare - <PREPARE,v,n,d,i>
- commit - <COMMIT,v,n,D(m),i>


#### 详细算法
首先，客户端向主节点发起请求，主节点 0 收到客户端请求，会向其它节点发送 pre-prepare 消息，其它节点就收到了pre-prepare 消息，就开始了这个核心三阶段共识过程了。

Pre-prepare 阶段：节点收到 pre-prepare 消息后，会有两种选择，一种是接受，一种是不接受。什么时候才不接受主节点发来的 pre-prepare 消息呢？一种典型的情况就是如果一个节点接受到了一条 pre-pre 消息，消息里的 v 和 n 在之前收到里的消息是曾经出现过的，但是 d 和 m 却和之前的消息不一致，或者请求编号不在高低水位之间（高低水位的概念在下文会进行解释），这时候就会拒绝请求。拒绝的逻辑就是主节点不会发送两条具有相同的 v 和 n ，但 d 和 m 却不同的消息。

Prepare 阶段：节点同意请求后会向其它节点发送 prepare 消息。这里要注意一点，同一时刻不是只有一个节点在进行这个过程，可能有 n 个节点也在进行这个过程。因此节点是有可能收到其它节点发送的 prepare 消息的。在一定时间范围内，如果收到超过 2f 个不同节点的 prepare 消息，就代表 prepare 阶段已经完成。

Commit 阶段：于是进入 commit 阶段。向其它节点广播 commit 消息，同理，这个过程可能是有 n 个节点也在进行的。因此可能会收到其它节点发过来的 commit 消息，当收到 2f+1 个 commit 消息后（包括自己），代表大多数节点已经进入 commit 阶段，这一阶段已经达成共识，于是节点就会执行请求，写入数据。
处理完毕后，节点会返回消息给客户端，这就是 pbft 算法的全部流程。

## PBFT的三阶段必要性
PBFT 算法需要三个阶段，是因为会面临view-change的问题（即主节点变化，引起节点执行状态发生变化）。

如简化为两个阶段 pre-prepare 和 prepare，当一个节点 A 收到 2f+1 个相同的 prepare 后执行请求，一部分节点 B 发生 view-change，在 view-change 的过程中是拒收 prepare 消息的，所以这一部分节点的状态机会少执行一个请求，当 view-change 切换成功后重放 prepare 消息，在重放的过程中，节点 A 也完成了 view-change，这个时候 A 就会面临重放的 prepare 已经执行过了，是否需要再次执行？会导致状态机出现二义性。

因此，pre-prepare 和 prepare 阶段最重要的任务是保证，同一个 主节点 发出的请求在同一个 视图（view） 中的顺序是一致的，prepare 和 commit 阶段最重要的任务是保证请求在不同 视图 之间的顺序是一致的。

## 安全分析
TBC


## 特点
- TPS速度快
- 可以容错故障节点和恶意节点
- 由于以上特点，适合使用在联盟链中

## Q&A
TBC
