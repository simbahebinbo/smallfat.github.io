## <center>深入浅出零知识证明系列 1-交互式零知识证明：从多项式谈起</center>

## 交互式零知识证明
#### 交互式的涵义
零知识证明过程中，有两个角色verifier和prover。在证明的过程中，如果verifier和prover会进行多次信息的传递，就称之为交互式。

#### 零知识证明证明什么
在零知识证明中，所有的现实问题，都会转换为一个多项式。最终的证明目的，是prover需要向verifier证明，其知道该多项式，即知道该多项式的知识（多项式系数）；且在证明的过程中，prover不能向verifier泄露任何关于该多项式的信息。

## 多项式
#### 多项式的特性
###### 多项式的知识
一个多项式的知识，就是该多项式的系数。    

###### Schwatz-Zippel多项式定理
- 如果我们有两个阶为 d 的不相等多项式，他们相交的点数不会超过 d
- 我们不可能找到两条不同的曲线，他们会在某段区域内重合（他们只会相交于一些点）
- 由于上述两个原因，任何多项式在任意点的计算结果都可以看做是其唯一身份的表示（概率意义上），这构成了以多项式曲线上某随机点证明某个多项式的基础

###### 基于Schwatz-Zippel定理的证明
一个 prover 声称他知道一些 verifier也知道的多项式（无论多项式的阶数有多大）时，他们就可以按照一个简单的协议去验证：
1. verifier 选择一个随机值 x 并在本地计算多项式结果
2. verifier 将 x 值给到 prover，并让他计算相关的多项式结果
3. prover 代入 x 到多项式计算并将结果给到 verifier
4. verifier 检查本地的计算结果和 prover 的计算结果是否相等，如果相等那就说明 prover 的陈述具有较高的可信度

- 问题1：点3成立的理由应该是校验点的随机性，而不是Schwatz-Zippel定理？
- 缺陷1：verifier和prover都知道此多项式
- 缺陷2：verifier选择的随机点x是明文给prover的，存在信息泄露的风险

###### 基于多项式因式分解的证明
- prover知道p(x) 的证明流程
    1. 将p(x)进行因式分解，p(x) = t(x)·h(x)， 其中，tx = (x-a0)(x-a1)…(x-an) , h(x)则是辅助多项式。a0...an是方程p(x) = 0的解。
    2. verifier知道t(x)
    3. verifier 挑选一个随机值 r, 计算 t = t(r) (即，求值) ，然后将 r 发送给 prover
    4. prover 计算 h(x) =p(x) / t(x) ，并对 p(r) 和 h(r) 进行求值，将计算结果 p, h 提供给 verifier
    5. verifier 验证 p= t⋅h，如果多项式相等，就意味着 t(x) 是 p(x) 的因式。
- 上述证明解决了[基于Schwatz-Zippel定理的证明]的缺陷: verifier只需要知道t(x),不需要知道p(x)
- 上述证明有如下明显缺陷：
    1. prover 可能并不知道他所声称的 p(x)，他可以先算一下  t = t(r)，然后选择一个随机值 h，由此计算出 p = t⋅h。因为等式是成立的，所以也能通过 verifier 的校验。
    2. 因为 prover 知道随机点 x = r ，他可以构造出一个任意的多项式，这个任意多项式与 t(r) ⋅ h(r) 在 r 处有共同点。
    3. 在前面的「陈述」中，prover声称他知道一个特定阶数的多项式，但现在的协议对阶数并没有明确的要求。因而 prover 完全可以拿一个满足因式校验的更高阶数的多项式来欺骗 verifier。
- 上述证明的前两点缺陷，是由于verifier明文传送随机值r给prover导致的。


未完待续......
